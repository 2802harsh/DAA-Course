\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{bm,amsbsy,amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage[ruled,vlined,linesnumbered]{algorithm2e}
\usepackage{xcolor}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
    
\begin{document}

\title{Counting Number of Inversions in an Array\\
{\footnotesize B.tech Semester 4th}
\thanks{}
}

\author{\IEEEauthorblockN{ Harshdeep Singh Pruthi}
\IEEEauthorblockA{\textit{IIT2019105}}
\and
\IEEEauthorblockN{ Jayaram Naik}
\IEEEauthorblockA{\textit{IIT2019106}}
\and
\IEEEauthorblockN{ Shivansh Gupta}
\IEEEauthorblockA{\textit{IIT2019107}}
}

\maketitle

\noindent \begin{abstract}
In this report we have devised an algorithm on how to count the Number of Inversions in an Array.
We have discussed in detail the Divide and Conquer Approach for this problem and discussed why it works and have compared it with the Naive Approach, on what makes it better.
\end{abstract}

\noindent \begin{IEEEkeywords}
Inversion, Divide and Conquer, Merge Sort
\end{IEEEkeywords}

\section{\textbf{Introduction}}
\noindent Consider an array A, and two indices $\bm{i}$ and $\bm{j}$, such that $\bm{i}<\bm{j}$ and $\bm{A[i]} > \bm{A[j]}$. This is called an inversion in the array. Thus, the Inversion Count of an array is the count of all the pairs $\bm{(i,j)}$ such that $\bm{i}<\bm{j}$ and $\bm{A[i]}>\bm{A[j]}$ \\

\begin{figure}[htbp]
\centerline{\includegraphics{inversion.png}}
\caption{An example of inversion in array.}
\label{fig}
\end{figure}

\noindent Thus, in the above figure indices $(0,1) , (0,2) , (0,4)$ are called inversions. \\
An important observation here is that Inversion Count can be seen to be closely associated with Sorting of an array. If we find out all the inversions in an array and replace the elements at the indices $\bm{i}$ and $\bm{j}$ to the point that no inversion now exists, the array will be sorted. \\
Thus, Inversion Count for an array indicates â€“ how far the array is from being sorted. If the array is already sorted, then the inversion count is 0, and it would be maximum when the array is sorted in decreasing order. \\
This relationship between inversions and a sorted array is going to be the key for devising a Divide and Conquer algorithm for this problem which shall follow in the subsequent sections.


\section{\textbf{Algorithm Description and Analysis}}

\subsection{Naive}

\noindent The Naive approach is fairly simple. It involves a Brute Force approach where we iterate over all the pairs of the array (which can be done through a nested loop), and if any pair $(i,j)$ satisfies our condition, we increase our Inversion Count by one.

\subsection{Divide and Conquer}
\noindent For the Divide and Conquer approach, suppose we divide our array A into two equal, or almost equal parts. Let's call the first one \textbf{L} and the other one \textbf{R}. Also, let's say we know the Inversion Count of both \textbf{L} and \textbf{R}. Let's call them $\bm{inv_1}$ and $\bm{inv_2}$. \\
Now, suppose we want to count the number of inversions inside the array A. Now any inversion $\bm{(i,j)}$ in \textbf{A} would be of one of the following types: \\

\begin{enumerate}
  \item  $\bm{i \in L}$ and $\bm{j \in R}$.
  \item  $\bm{i \in L}$ and $\bm{j \in L}$.
  \item  $\bm{i \in R}$ and $\bm{j \in R}$.
\end {enumerate}

\begin{itemize}
    \item Let's consider the first case. First of all, it's clear that the total inversions of \textbf{A} now will include the inversions of both \textbf{L} and \textbf{R} ,i.e., $\bm{inv_1} + \bm{inv_2}$. But there may be some more inversions, for when we will $\bm{merge}$ \textbf{L} and \textbf{R}. And that is the major step in this case - computing for each index $\bm{i \in L}$, the number of indices $\bm{j \in R}$ such that L\textsubscript i $>$ R\textsubscript j.\\
    Now, let's say that we have sorted the arrays \textbf{L} and \textbf{R}. and their sizes are \textbf{N} and \textbf{M} respectively. \\
    Also, now consider we are using $\bm{k}$ and $\bm{l}$ to iterate over \textbf{L} and \textbf{R}. Say, at certain point we encounter $\bm{L[l]} > \bm{R[k]}$.\\
    Now, because \textbf{L} and \textbf{R} are sorted, we know that there are going to be \textbf{N-i} more inversions in \textbf{A}, because all elements to the right of $\bm{L[l]}$ will also be greater than $\bm{R[k]}$.\\
    Note that it doesn't matter that the elements are now sorted, because all the elements of \textbf{L} existed to the left of all elements \textbf{R} in the original array \textbf{A}, so these inversions will be present in one or another order in \textbf{A}.
    \\
    \item Now for the second and the third case: If we encounter that situation, we again divide them up into further two arrays and repeat this recursively, until we have arrived on the base case - that includes just one element. And in this case, we know the inversions will be $0$, because there is just a single element in the array.
\end{itemize}

Here, one more important thing is that in the first case, we require the arrays \textbf{L} and \textbf{R} to be sorted. To achieve that, the algorithm must sort them. In other words, after applying the algorithm to both L and R, they become sorted. To sort \textbf{A} we just merge the two sorted arrays \textbf{L} and \textbf{R} into \textbf{A}.

\section{\textbf{Pseudo Code}}
\noindent We will be creating two functions: \textbf{enhancedMergeSort} and \textbf{mergeTwoArrays}. The former will divide up the array recursively into halves and call the latter function for these divided arrays and the latter function will sort the arrays and in the process return the Inversion Count which is ultimately added up to return the final answer.


\begin{algorithm}
\DontPrintSemicolon

    \KwData{$\bm{arr}$: The Array\\
         $\bm{beg}$: Start iterator\\
         $\bm{mid}$: Middle iterator\\
         $\bm{end}$: End iterator\\}
  \KwResult{Returns the total number of inversions in the procedure of merging two arrays $\bm{arr[beg...mid]}$ and $\bm{arr[mid+1...end]}$}
  $i,k=beg$\\
  $j=end$\\
  $newarr$\\
  \While{$i<mid$ AND $j<=end$}
  {
    \tcc{No Inversion}
    \If{$arr[i]<arr[j]$}
    {
        newarr[k]=arr[i]\\
        increment k,i
    }
    \tcc{mid-i inversions}
    \Else{
        newarr[k]=arr[j]\\
        invCount+= $mid-i$\\
        increment k,j
    }
  }
  \While{$i<mid$}{
    temp[k] = arr[i]\\
    increment k,i
  }
  \While{$j,end$}{
    temp[k] = arr[j]\\
    increment k,j
  }
  it = beg
\tcc{Copy all the elements of newarr into arr}
  \While{$it < end$}{
    arr[it] = newarr[it]
    increment it
  }
  return $invCount$
\caption{mergeTwoArrays}
\end{algorithm}

\begin{algorithm}
\DontPrintSemicolon
  
  \KwData{$\bm{arr}$: The Array\\
         $\bm{beg}$: Start iterator\\
         $\bm{end}$: End iterator\\}
  \KwResult{Returns the total number of inversions in the array arr from $\bm{beg}$ to $\bm{end}$}
  $mid, invCount=0$\\
  \If{$end>beg$}
    {
        mid = (beg+end)/2
        
        \tcc{Call recursively and add returned value to invCount}
        invCount += enhancedMergeSort(arr,left,mid)\\
        invCount += enhancedMergeSort(arr,mid+1,right)
        \\
        \tcc{Finally merge these divided arrays up using the merge function which also return inversions count for this step}
        invCount += mergeTwoArrays(arr,left,mid+1,right)
    }
    
    return $invCount$\\
\caption{enhancedMergeSort}
\end{algorithm}


\section*{Acknowledgment}


\begin{thebibliography}{00}
\bibitem{b1} G. Eason, B. Noble, and I. N. Sneddon, ``On certain integrals of Lipschitz-Hankel type involving products of Bessel functions,'' Phil. Trans. Roy. Soc. London, vol. A247, pp. 529--551, April 1955.
\end{thebibliography}
\vspace{12pt}

\end{document}
